=head1 Upgrading to Catalyst 5.80

Most applications and plugins should run unaltered on Catalyst 5.80.

However as a lot of refactoring work has taken place, several changes
have been made which could cause incompatibilties, if your application
or plugin is using deprecated code, or relying on side-effects then
there could be incompatibility.

Most issues found with pre-existing components have been easy to solve, 
and a complete description of behavior changes which may cause compatibility
issues, or warnings to be emitted is included below to help if you have
problems.

If you think you have found an upgrade related issue which is not covered in
this document, then please email the Catalyst list to discuss the problem.

=head1 Known backwards compatibility breakages.

=head2 Moose applications

Moose components for Catalyst 5.70 needed to do

    extends qw/Moose::Object Catalyst::Component/;

to be able to use the constructor provided by Moose. In 5.80
C<Catalyst::Component> already inherits from C<Moose::Object>. Therefor you
shouldn't directly inherit from C<Moose::Object> yourself, otherwise your
Class' @ISA will not linearise with C3.

=head2 Anonymous closures installed directly into the symbol table

If you have any code which installs anonymous subroutine references directly
into the symbol table, you may encounter breakages. The simplest solution is
to use L<Sub::Name> to name the subroutine. Example:

    #Originalcode, likely to break:
    my $full_method_name = join('::',$package_name, $method_name);
    *$full_method_name = sub { ... };

    #Fixed Code
    use Sub::Name 'subname';
    my $full_method_name = join('::',$package_name, $method_name);
    *$full_method_name = subname $full_method_name, sub { ... };

Additionally, you can take advantage of Catalyst's use of L<Class::MOP> and
install the closure using the appropriate metaclass. Example:

    use Class::MOP;
    my $metaclass = Moose::Meta::Class->initialize($package_name);
    $metaclass->add_method($method_name => sub { ... });

=head2 Components whos new method returns false

Previously if your new method returned a false value, 

Previously, if you had a component which inherited from Catalyst::COMPONENT, but 
overrode the new method, to return false, then your class' configuration would be blessed into a hash on your behalf,
and this would be returned from the COMPONENT method. T

This behaviour makes no sense, and so has been removed.. You are recommended to implement your own new method
in components, instead, you should inherit the new method from Catalyst::Component, and use Moose's BUILD functionality
to perform any construction work necessary for your sub-class.

=head2 __PACKAGE__->mk_accessor('meta');

Won't work due to a limitation of L<Moose>

This is currently being fixed inside core Moose.

=head2 Class::Data::Inheritable side effects

Previously, writing to a class data accessor would copy the accessor method down into your package.

This behavior has been removed. Whilst the class data is still stored per-class, it is stored on
the metaclass of the class defining the accessor.

Therefore anything relying on the side-effect of the accessor being copied down will be broken.

=head2 Extending Catalyst::Request or other classes in an ad-hoc manor using mk_accessors

Previously, it was possible to add additional accessors to Catalyst::Request (or other classes)
by calling the mk_accessors class method.

This is no longer supported - users should make a sub-class of the class who's behavior they would
like to change, rather than globally polluting the Catalyst objects.

=head2 Confused multiple inheritence with Catalyst::Component::COMPONENT

Warning message:

    There is a COMPONENT method resolving after Catalyst::Component 
    in ${next_package}.
    
This means that one of the packages on the right hand side of 
Catalyst::Component in your Class' inheritance hierarchy defines
a COMPONENT method.

Previously, Catalyst's COMPONENT method would delegate to the
method on the right hand side, which could then delegate back again
with NEXT. This (as it is insane), is no longer supported, as it
makes no sense with C3 method dispatch order.

Therefore the correct fix is to re-arrange your class' inheritance
hierarchy so that the COMPONENT method you would like to inherit is
the first COMPONENT method in your @ISA. 

=head2 Assigning lists to accessors

Accessors generated by Class::Accessor::Fast will, when multiple values
are assigned to them, store a reference to a list automatically for you.

This is not currently supported by MooseX::Emulate::Class::Accessor::Fast,
and only the first value in the list will be stored.

If you are relying on this behavior, and inheriting mk_accessors from a
Catalyst component, then your code will fail.

=head1 WARNINGS

=head2 Methods in Catalyst::Dispatcher

The following methods in Catalyst::Dispatcher are likely to change 
significantly in the 5.8X release series, and therefore their use is highly
deprecated.

=over

=item tree 

=item dispatch_types 

=item registered_dispatch_types 

=item method_action_class  

=item action_hash 

=item container_hash

=back

The first time one of these methods is called, a warning will be emitted:

    Class $class is calling the deprecated method Catalyst::Dispatcher::$public_method_name,\n"
    . "this will be removed in Catalyst 5.9X"

You should B<NEVER> be calling any of these methods from application code.

Plugins authors and maintainers whos plugins need to call these methods 
should email the development list to discuss your use-case, and what a 
better API should look like.

=head2 require $class was successful but the package is not defined.

In this version of Catalyst, if a component is loaded from disk, but no symbols are defined in that component's namespace
after it is loaded, this warning will be issued.

This is to pretect against confusing bugs caused by mis-typing package names.

This will become a fatal error in a future version.

=head2 $c->plugin method

Calling the plugin method is deprecated, and calling it at runtime is B<highly deprecated>.

Instead you are recommended to use L< Catalyst::Model::Adaptor > or similar to compose the functionality
you need outside of the main application namespace.

=cut
